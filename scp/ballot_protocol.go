package scp

import (
	"bytes"
	"math"
	"sort"
	"time"

	"github.com/sirupsen/logrus"
	"github.com/stellar/go/support/log"
	"github.com/stellar/go/xdr"
)

// max number of transitions that can occur from processing one message
const MaxAdvanceSlotRecursion = 50

// Interval is [low,high] represented as a pair
type Interval struct {
	From uint32
	To   uint32
}

// used to filter statements
type StatementPredicate func(*xdr.ScpStatement) bool

type EnvelopeMap []*xdr.ScpEnvelope

func (m *EnvelopeMap) Get(key xdr.PublicKey) *xdr.ScpEnvelope {
	k := *key.Ed25519
	for _, env := range *m {
		if *env.Statement.NodeId.Ed25519 == k {
			return env
		}
	}
	return nil
}

func (m *EnvelopeMap) Put(key xdr.PublicKey, e *xdr.ScpEnvelope) {
	k := *key.Ed25519
	for i, env := range *m {
		if *env.Statement.NodeId.Ed25519 == k {
			(*m)[i] = e
			return
		}
	}

	*m = append(*m, e)
}

type BallotSet []xdr.ScpBallot

func (s *BallotSet) insert(i int, b xdr.ScpBallot) {
	*s = append(*s, xdr.ScpBallot{})
	copy((*s)[i+1:], (*s)[i:])
	(*s)[i] = b
}

func (s *BallotSet) Put(v xdr.ScpBallot) bool {
	for i := 0; i < len(*s); i++ {
		if v.Counter < (*s)[i].Counter {
			s.insert(i, v)
			return true
		}

		if v.Counter == (*s)[i].Counter {
			c := bytes.Compare(v.Value, (*s)[i].Value)
			if c < 0 {
				s.insert(i, v)
				return true
			}
			if c == 0 {
				return false
			}
		}
	}

	*s = append(*s, v)
	return true
}

func (s *BallotSet) Contains(v xdr.ScpBallot) bool {
	for _, value := range []xdr.ScpBallot(*s) {
		if value.Counter != v.Counter {
			continue
		}
		if bytes.Compare(value.Value, v.Value) == 0 {
			return true
		}
	}

	return false
}

type Phase int

const (
	PhasePrepare Phase = iota + 1
	PhaseConfirm
	PhaseExternalize
)

type BallotProtocol struct {
	slot *Slot

	// last envelope generated by this node
	lastEnvelope *xdr.ScpEnvelope

	heardFromQuorum bool

	// last envelope emitted by this node
	lastEnvelopeEmit *xdr.ScpEnvelope

	currentBallot   *xdr.ScpBallot //b
	prepared        *xdr.ScpBallot //p
	preparedPrime   *xdr.ScpBallot //p'
	highBallot      *xdr.ScpBallot //h
	commit          *xdr.ScpBallot //c
	latestEnvelopes EnvelopeMap
	valueOverride   xdr.Value //z
	Phase

	currentMessageLevel int // number of messages triggered in one run
}

func NewBallotProtocol(slot *Slot) *BallotProtocol {
	return &BallotProtocol{
		slot:                slot,
		heardFromQuorum:     false,
		Phase:               PhasePrepare,
		currentMessageLevel: 0,
	}
}

func (b *BallotProtocol) Slot() *Slot {
	return b.slot
}

func (b *BallotProtocol) getLatestMessageSend() *xdr.ScpEnvelope {
	return b.lastEnvelopeEmit
}

func (b *BallotProtocol) GetLocalNode() *LocalNode {
	return b.Slot().LocalNode()
}

func (b *BallotProtocol) StopTimer() {
	b.Slot().SCPDriver().SetupTimer(
		b.Slot().Index(),
		BallotTimer,
		time.Duration(0),
		nil,
	)
}

func (b *BallotProtocol) StartTimer() {
	timeout := b.Slot().SCPDriver().ComputeTimeout(uint32(b.currentBallot.Counter))

	b.Slot().SCPDriver().SetupTimer(
		b.Slot().Index(),
		BallotTimer,
		timeout,
		b.slot.BallotProtocol().TimerExpired,
	)
}

func (b *BallotProtocol) TimerExpired() {
	b.AbandonBallot(0)
}

func (b *BallotProtocol) AbandonBallot(n uint32) bool {
	log.Debug("BallotProtocol: abandonBallot")

	v := b.Slot().LatestCompositeCandidate()
	if v == nil {
		if b.currentBallot != nil {
			v = b.currentBallot.Value
		}
	}

	if v != nil {
		if n != 0 {
			return b.BumpStateF(v, n)
		}
		return b.BumpState(v, true)
	}

	return false
}

func (b *BallotProtocol) CheckHeardFromQuorum() {
	// this method is safe to call regardless of the transitions of the other
	// nodes on the network:
	// we guarantee that other nodes can only transition to higher counters
	// (messages are ignored upstream)
	// therefore the local node will not flip flop between "seen" and "not seen"
	// for a given counter on the local node
	if b.currentBallot == nil {
		return
	}

	if !IsQuorum(
		b.LocalNode().QuorumSet(),
		b.latestEnvelopes,
		b.Slot().GetQuorumSetFromStatement,
		func(st *xdr.ScpStatement) bool {
			if st.Pledges.Type == xdr.ScpStatementTypeScpStPrepare {
				return b.currentBallot.Counter <= st.Pledges.Prepare.Ballot.Counter
			}

			return true
		},
	) {
		b.heardFromQuorum = false
		b.StopTimer()
		return
	}

	oldHQ := b.heardFromQuorum
	b.heardFromQuorum = true
	if !oldHQ {
		// if we transition from not heard -> heard, we start the timer
		b.Slot().SCPDriver().BallotDidHearFromQuorum(
			b.Slot().Index(),
			b.currentBallot,
		)
		if b.Phase != PhaseExternalize {
			b.StartTimer()
		}
	}

	if b.Phase == PhaseExternalize {
		b.StopTimer()
	}

}

func (b *BallotProtocol) BumpStateF(value xdr.Value, n uint32) bool {
	if b.Phase != PhasePrepare && b.Phase != PhaseConfirm {
		return false
	}

	newb := xdr.ScpBallot{
		Counter: xdr.Uint32(n),
	}

	if b.valueOverride != nil {
		// we use the value that we saw confirmed prepared
		// or that we at least voted to commit to
		newb.Value = b.valueOverride
	} else {
		newb.Value = value
	}

	log.WithFields(log.F{
		"slotIdx": b.slot.Index(),
		//ballot to str
	})

	updated := b.UpdateCurrentValue(&newb)
	if updated {
		b.EmitCurrentStateStatement()
		b.CheckHeardFromQuorum()
	}

	return updated
}

func (b *BallotProtocol) LocalNode() *LocalNode {
	return b.slot.SCP().LocalNode()
}

func (b *BallotProtocol) CreateStatement(t xdr.ScpStatementType) *xdr.ScpStatement {
	b.checkInvariants()

	statement := new(xdr.ScpStatement)

	statement.Pledges.Type = t
	switch t {
	case xdr.ScpStatementTypeScpStPrepare:
		p := &xdr.ScpStatementPrepare{
			QuorumSetHash: b.LocalNode().QuorumSetHash(),
			Prepared:      b.prepared,
			PreparedPrime: b.preparedPrime,
		}
		statement.Pledges.Prepare = p

		if b.currentBallot != nil {
			p.Ballot = *b.currentBallot
		}

		if b.commit != nil {
			p.NC = b.commit.Counter
		}

		if b.highBallot != nil {
			p.NH = b.highBallot.Counter
		}
	case xdr.ScpStatementTypeScpStConfirm:
		statement.Pledges.Confirm = &xdr.ScpStatementConfirm{
			QuorumSetHash: b.LocalNode().QuorumSetHash(),
			Ballot:        *b.currentBallot,
			NPrepared:     b.prepared.Counter,
			NCommit:       b.commit.Counter,
			NH:            b.highBallot.Counter,
		}
	case xdr.ScpStatementTypeScpStExternalize:
		statement.Pledges.Externalize = &xdr.ScpStatementExternalize{
			Commit:              *b.commit,
			NH:                  b.highBallot.Counter,
			CommitQuorumSetHash: b.LocalNode().QuorumSetHash(),
		}
	default:
		panic("unknown scp statement type")
	}

	return statement
}

func (b *BallotProtocol) EmitCurrentStateStatement() {
	var t xdr.ScpStatementType

	switch b.Phase {
	case PhasePrepare:
		t = xdr.ScpStatementTypeScpStPrepare
	case PhaseConfirm:
		t = xdr.ScpStatementTypeScpStConfirm
	case PhaseExternalize:
		t = xdr.ScpStatementTypeScpStExternalize
	default:
		panic("unknown scp phase")
	}

	statement := b.CreateStatement(t)
	envelope := b.slot.CreateEnvelope(statement)

	canEmit := b.currentBallot != nil

	// if we generate the same envelope, don't process it again
	// this can occur when updating h in PREPARE phase
	// as statements only keep track of h.n (but h.x could be different)
	lastEnv := b.latestEnvelopes.Get(b.slot.SCP().LocalNodeID())

	if lastEnv != nil && EnvelopeEq(lastEnv, envelope) {
		return
	}

	if b.slot.ProcessEnvelope(envelope, true) != EnvelopeStateValid {
		// there is a bug in the application if it queued up
		// a statement for itself that it considers invalid
		panic("moved to a bad state (ballot protocol)")
	}

	if canEmit && (b.lastEnvelope == nil || b.IsNewerStatement(&b.lastEnvelope.Statement, &envelope.Statement)) {
		b.lastEnvelope = envelope
		// this will no-op if invoked from advanceSlot
		// as advanceSlot consolidates all messages sent
		b.SendLatestEnvelope()
	}
}

func (b *BallotProtocol) SendLatestEnvelope() {
	// emit current envelope if needed
	if b.currentMessageLevel == 0 && b.lastEnvelope != nil && b.slot.FullyValidated() {
		if b.lastEnvelopeEmit == nil || b.lastEnvelope != b.lastEnvelopeEmit {
			b.lastEnvelopeEmit = b.lastEnvelope
			b.slot.SCPDriver().EmitEnvelope(b.lastEnvelopeEmit)
		}
	}
}

func (b *BallotProtocol) IsNewerStatementN(node xdr.PublicKey, st *xdr.ScpStatement) bool {
	oldp := b.latestEnvelopes.Get(node)
	if oldp == nil {
		return true
	}

	return b.IsNewerStatement(&oldp.Statement, st)
}

func (b *BallotProtocol) IsNewerStatement(oldst *xdr.ScpStatement, st *xdr.ScpStatement) bool {
	// total ordering described in SCP paper.
	t := st.Pledges.Type

	// statement type (PREPARE < CONFIRM < EXTERNALIZE)
	if oldst.Pledges.Type != t {
		return oldst.Pledges.Type < t
	}

	// can't have duplicate EXTERNALIZE statements
	if t == xdr.ScpStatementTypeScpStExternalize {
		return false
	}

	if t == xdr.ScpStatementTypeScpStConfirm {
		// sorted by (b, p, p', h) (p' = 0 implicitely)
		oldC := oldst.Pledges.Confirm
		c := st.Pledges.Confirm

		compBallot := compareBallots(&oldC.Ballot, &c.Ballot)
		if compBallot < 0 {
			return true
		}

		if compBallot == 0 {
			if oldC.NPrepared == c.NPrepared {
				return oldC.NH < c.NH
			}

			return oldC.NPrepared < c.NPrepared
		}

		return false
	}

	// Lexicographical order between PREPARE statements:
	// (b, p, p', h)
	oldPrep := oldst.Pledges.Prepare
	prep := st.Pledges.Prepare

	compBallot := compareBallots(&oldPrep.Ballot, &prep.Ballot)
	if compBallot < 0 {
		return true
	}

	if compBallot != 0 {
		return false
	}

	compBallot = compareBallots(oldPrep.Prepared, prep.Prepared)
	if compBallot < 0 {
		return true
	}

	if compBallot != 0 {
		return false
	}

	compBallot = compareBallots(oldPrep.PreparedPrime, prep.PreparedPrime)
	if compBallot < 0 {
		return true
	}

	if compBallot != 0 {
		return false
	}

	return oldPrep.NH < prep.NH
}

func (b *BallotProtocol) UpdateCurrentValue(ballot *xdr.ScpBallot) bool {
	if b.Phase != PhasePrepare && b.Phase != PhaseConfirm {
		return false
	}

	updated := false
	if b.currentBallot == nil {
		b.BumpToBallot(ballot, true)
		updated = true
	} else {
		if b.commit != nil && !areBallotsCompatible(b.commit, ballot) {
			return false
		}

		comp := compareBallots(b.currentBallot, ballot)
		if comp > 0 {
			// this code probably changes with the final version
			// of the conciliator

			// this case may happen if the other nodes are not
			// following the protocol (and we end up with a smaller value)
			// not sure what is the best way to deal
			// with this situation

			log.Error("BallotProtocol: UpdateCurrentValue attempt to bump to a smaller value")
			// can't just bump to the value as we may already have
			// statements at counter+1
			return false
		}

		if comp < 0 {
			b.BumpToBallot(ballot, true)
			updated = true
		}
	}

	if updated {
		logrus.Trace("BallotProtocol: updateCurrentValue updated")
	}

	b.checkInvariants()

	return updated
}

func (b *BallotProtocol) checkInvariants() {
	if b.currentBallot != nil && b.currentBallot.Counter == 0 {
		panic("0 current ballot counter!")
	}

	if b.prepared != nil && b.preparedPrime != nil {
		if !areBallotsLessAndIncompatible(b.preparedPrime, b.prepared) {
			panic("prepared & prepared prime are compatible")
		}
	}

	if b.highBallot != nil {
		if b.currentBallot == nil {
			panic("nil current ballot")
		}

		if !areBallotsLessAndCompatible(b.highBallot, b.currentBallot) {
			panic("high & current ballots are imcompatible")
		}
	}

	if b.commit != nil {
		if b.currentBallot == nil {
			panic("nil current ballot")
		}

		if !areBallotsLessAndCompatible(b.commit, b.highBallot) {
			panic("high & commit ballots are imcompatible")
		}
		if !areBallotsLessAndCompatible(b.highBallot, b.currentBallot) {
			panic("high & current ballots are imcompatible")
		}
	}

	switch b.Phase {
	case PhasePrepare:
	case PhaseConfirm:
		if b.commit == nil {
			panic("nil commit ballot at confirm phase")
		}
	case PhaseExternalize:
		if b.commit == nil {
			panic("nil commit ballot at externalize phase")
		}
		if b.highBallot == nil {
			panic("nil highBallot at externalize phase")
		}
	default:
		panic("unknown scp phase")
	}

}

func areBallotsLessAndIncompatible(b1 *xdr.ScpBallot, b2 *xdr.ScpBallot) bool {
	return compareBallots(b1, b2) <= 0 && !areBallotsCompatible(b1, b2)
}

func areBallotsLessAndCompatible(b1 *xdr.ScpBallot, b2 *xdr.ScpBallot) bool {
	return compareBallots(b1, b2) <= 0 && areBallotsCompatible(b1, b2)
}

func areBallotsCompatible(b1 *xdr.ScpBallot, b2 *xdr.ScpBallot) bool {
	a := bytes.Compare(b1.Value, b2.Value) == 0
	return a
}

func compareBallots(b1 *xdr.ScpBallot, b2 *xdr.ScpBallot) int {
	comp := func() int {
		if b1.Counter < b2.Counter {
			return -1
		}

		if b2.Counter < b1.Counter {
			return 1
		}

		// ballots are also strictly ordered by value
		return bytes.Compare(b1.Value, b2.Value)
	}

	if b1 != nil && b2 != nil {
		return comp()
	}

	if b1 != nil && b2 == nil {
		return 1
	}

	if b1 == nil && b2 != nil {
		return -1
	}

	return 0
}

func (b *BallotProtocol) BumpToBallot(ballot *xdr.ScpBallot, check bool) {
	log.WithFields(log.F{
		"slotIdx": b.slot.Index(),
		//"ballotStr": b.slot.SCP().BallotStr()
	}).Debug("BallotProtocol: bumpToBallot")

	// `bumpToBallot` should be never called once we committed.
	if b.Phase == PhaseExternalize {
		log.Error("bumpToBallot called once we commited!")
	}

	if check {
		// We should move mCurrentBallot monotonically only
		if !(b.currentBallot == nil || compareBallots(ballot, b.currentBallot) >= 0) {
			log.Error("current ballot has been moved unmonotonically!")
		}
	}

	gotBumped := b.currentBallot == nil || b.currentBallot.Counter != ballot.Counter

	if b.currentBallot == nil {
		b.slot.SCPDriver().StartedBallotProtocol(b.slot.Index(), ballot)
	}

	b.currentBallot = ballot
	// invariant: h.value = b.value
	if b.highBallot != nil && !areBallotsCompatible(b.currentBallot, b.highBallot) {
		b.highBallot = nil
	}

	if gotBumped {
		b.heardFromQuorum = false
	}
}

func (b *BallotProtocol) BumpState(value xdr.Value, force bool) bool {
	if !force && b.currentBallot != nil {
		return false
	}

	n := uint32(1)
	if b.currentBallot != nil {
		n = uint32(b.currentBallot.Counter) + 1
	}

	return b.BumpStateF(value, n)
}

func (b *BallotProtocol) IsStatementSane(st *xdr.ScpStatement, self bool) bool {
	qSet := b.slot.GetQuorumSetFromStatement(st)
	if !(qSet != nil && isQuorumSetSane(qSet, false)) {
		log.Debug("Invalid quorum set received")
		return false
	}

	switch st.Pledges.Type {
	case xdr.ScpStatementTypeScpStPrepare:
		p := st.Pledges.MustPrepare()

		// self is allowed to have b = 0 (as long as it never gets emitted)
		ok := (self || p.Ballot.Counter > 0) &&
			((p.Prepared == nil || p.PreparedPrime == nil) || areBallotsLessAndIncompatible(p.PreparedPrime, p.Prepared)) &&
			((p.NH == 0) || (p.Prepared != nil && p.NH <= p.Prepared.Counter)) &&
			// c != 0 -> c <= h <= b
			(p.NC == 0 || (p.NH != 0 && p.Ballot.Counter >= p.NH && p.NH >= p.NC))

		if !ok {
			log.Debug("malformed PREPARE message")
		}

		return ok
	case xdr.ScpStatementTypeScpStConfirm:
		c := st.Pledges.MustConfirm()

		res := c.Ballot.Counter > 0 && (c.NH <= c.Ballot.Counter) && (c.NCommit <= c.NH)
		if !res {
			log.Debug("Malformed CONFIRM message")
		}

		return res
	case xdr.ScpStatementTypeScpStExternalize:
		e := st.Pledges.MustExternalize()

		res := e.Commit.Counter > 0 && e.NH >= e.Commit.Counter
		if !res {
			log.Debug("Malformed EXTERNALIZE message")
			return false
		}
		return res
	default:
		panic("unknown scp statement type")
	}

}

func (b *BallotProtocol) ValidateValues(st *xdr.ScpStatement) ValidationLevel {
	values := make(XDRValueSet, 0)

	switch st.Pledges.Type {
	case xdr.ScpStatementTypeScpStPrepare:
		prep := st.Pledges.MustPrepare()
		if prep.Ballot.Counter != 0 {
			values.Put(prep.Ballot.Value)
		}
		if prep.Prepared != nil {
			values.Put(prep.Prepared.Value)
		}
	case xdr.ScpStatementTypeScpStConfirm:
		values.Put(st.Pledges.MustConfirm().Ballot.Value)
	case xdr.ScpStatementTypeScpStExternalize:
		values.Put(st.Pledges.MustExternalize().Commit.Value)
	default:
		// This shouldn't happen
		return ValidationLevelInvalid
	}

	res := ValidationLevelValid
	for _, v := range values {
		tr := b.slot.SCPDriver().ValidateValue(b.slot.Index(), v, false)
		if tr != ValidationLevelValid {
			if tr == ValidationLevelInvalid {
				res = ValidationLevelInvalid
			} else {
				res = ValidationLevelMaybe
			}
		}
	}

	return res
}

func (b *BallotProtocol) RecordEnvelope(env *xdr.ScpEnvelope) {
	// ???
	b.latestEnvelopes.Put(xdr.PublicKey(env.Statement.NodeId), env)
	b.slot.RecordStatement(&env.Statement)
}

func (b *BallotProtocol) GetPreparedCandidates(hint *xdr.ScpStatement) BallotSet {
	hintBallots := make(BallotSet, 0)

	switch hint.Pledges.Type {
	case xdr.ScpStatementTypeScpStPrepare:
		prep := hint.Pledges.MustPrepare()
		hintBallots.Put(prep.Ballot)
		if prep.Prepared != nil {
			hintBallots.Put(*prep.Prepared)
		}
		if prep.PreparedPrime != nil {
			hintBallots.Put(*prep.PreparedPrime)
		}
	case xdr.ScpStatementTypeScpStConfirm:
		con := hint.Pledges.MustConfirm()
		hintBallots.Put(xdr.ScpBallot{
			Counter: con.NPrepared,
			Value:   con.Ballot.Value,
		})
		hintBallots.Put(xdr.ScpBallot{
			Counter: math.MaxUint32,
			Value:   con.Ballot.Value,
		})
	case xdr.ScpStatementTypeScpStExternalize:
		ext := hint.Pledges.MustExternalize()
		hintBallots.Put(xdr.ScpBallot{
			Counter: math.MaxUint32,
			Value:   ext.Commit.Value,
		})
	default:
		panic("unknown scp statemnt type")
	}

	candidates := make(BallotSet, 0)
	for _, top := range hintBallots {
		// find candidates that may have been prepared
		for _, e := range b.latestEnvelopes {
			switch e.Statement.Pledges.Type {
			case xdr.ScpStatementTypeScpStPrepare:
				prep := e.Statement.Pledges.MustPrepare()
				if areBallotsLessAndCompatible(&prep.Ballot, &top) {
					candidates.Put(prep.Ballot)
				}
				if prep.Prepared != nil && areBallotsLessAndCompatible(prep.Prepared, &top) {
					candidates.Put(*prep.Prepared)
				}
				if prep.PreparedPrime != nil && areBallotsLessAndCompatible(prep.PreparedPrime, &top) {
					candidates.Put(*prep.PreparedPrime)
				}
			case xdr.ScpStatementTypeScpStConfirm:
				con := e.Statement.Pledges.MustConfirm()
				if areBallotsCompatible(&top, &con.Ballot) {
					candidates.Put(top)
					if con.NPrepared < top.Counter {
						candidates.Put(xdr.ScpBallot{
							Counter: con.NPrepared,
							Value:   top.Value,
						})
					}
				}
			case xdr.ScpStatementTypeScpStExternalize:
				ext := e.Statement.Pledges.MustExternalize()
				if areBallotsCompatible(&top, &ext.Commit) {
					candidates.Put(top)
				}
			default:
				panic("unknown scp statemnt type")
			}
		}
	}

	return candidates
}

func (b *BallotProtocol) FederatedAccept(voted StatementPredicate, accepted StatementPredicate) bool {
	return b.slot.FederatedAccept(voted, accepted, b.latestEnvelopes)
}

func (b *BallotProtocol) HasPreparedBallot(ballot *xdr.ScpBallot, st *xdr.ScpStatement) bool {
	switch st.Pledges.Type {
	case xdr.ScpStatementTypeScpStPrepare:
		p := st.Pledges.MustPrepare()
		return p.Prepared != nil && areBallotsLessAndCompatible(ballot, p.Prepared) ||
			(p.PreparedPrime != nil && areBallotsLessAndCompatible(ballot, p.PreparedPrime))
	case xdr.ScpStatementTypeScpStConfirm:
		c := st.Pledges.MustConfirm()
		prepared := xdr.ScpBallot{
			Counter: c.NPrepared,
			Value:   c.Ballot.Value,
		}
		return areBallotsLessAndCompatible(ballot, &prepared)
	case xdr.ScpStatementTypeScpStExternalize:
		e := st.Pledges.MustExternalize()
		return areBallotsCompatible(ballot, &e.Commit)
	}

	panic("unknown scp statement type")
}

func (b *BallotProtocol) SetPrepared(ballot *xdr.ScpBallot) bool {
	if b.prepared == nil {
		b.prepared = ballot
		return true
	}

	comp := compareBallots(b.prepared, ballot)
	if comp < 0 {
		if !areBallotsCompatible(b.prepared, ballot) {
			b.preparedPrime = b.prepared
		}
		b.prepared = ballot
		return true
	}

	if comp > 0 {
		// check if we should update only p'
		if b.preparedPrime == nil || compareBallots(b.preparedPrime, ballot) < 0 {
			b.preparedPrime = ballot
			return true
		}
	}

	return false
}

func (b *BallotProtocol) SetPreparedAccept(ballot *xdr.ScpBallot) bool {
	// update our state
	didWork := b.SetPrepared(ballot)

	// check if we also need to clear 'c'
	if b.commit != nil && b.highBallot != nil {
		if (b.prepared != nil && areBallotsLessAndIncompatible(b.highBallot, b.prepared)) ||
			(b.preparedPrime != nil && areBallotsLessAndIncompatible(b.highBallot, b.preparedPrime)) {
			b.commit = nil
			didWork = true
		}
	}

	if didWork {
		b.slot.SCPDriver().AcceptedBallotPrepared(b.slot.Index(), ballot)
		b.EmitCurrentStateStatement()
	}

	return didWork
}

func (b *BallotProtocol) AttemptPreparedAccept(hint *xdr.ScpStatement) bool {
	if b.Phase != PhasePrepare && b.Phase != PhaseConfirm {
		return false
	}

	candidates := b.GetPreparedCandidates(hint)

	// see if we can accept any of the candidates, starting with the highest
	for i := len(candidates) - 1; i >= 0; i-- {
		c := candidates[i]
		if b.Phase == PhaseConfirm {
			// only consider the ballot if it may help us increase
			// p (note: at this point, p ~ c)

			if !areBallotsLessAndCompatible(b.prepared, &c) {
				continue
			}
		}

		// if we already prepared this ballot, don't bother checking again

		// if ballot <= p' ballot is neither a candidate for p nor p'
		if b.preparedPrime != nil && compareBallots(&c, b.preparedPrime) <= 0 {
			continue
		}

		if b.prepared != nil {
			// if ballot is already covered by p, skip
			if areBallotsLessAndCompatible(&c, b.prepared) {
				continue
			}
			// otherwise, there is a chance it increases p'
		}

		accepted := b.FederatedAccept(
			// checks if any node is voting for this ballot
			func(st *xdr.ScpStatement) bool {
				switch st.Pledges.Type {
				case xdr.ScpStatementTypeScpStPrepare:
					p := st.Pledges.MustPrepare()
					return areBallotsLessAndCompatible(&c, &p.Ballot)
				case xdr.ScpStatementTypeScpStConfirm:
					co := st.Pledges.MustConfirm()
					return areBallotsCompatible(&c, &co.Ballot)
				case xdr.ScpStatementTypeScpStExternalize:
					e := st.Pledges.MustExternalize()
					return areBallotsCompatible(&c, &e.Commit)

				}
				panic("unknown scp statemnt type")
			},
			func(st *xdr.ScpStatement) bool {
				return b.HasPreparedBallot(&c, st)
			},
		)
		if accepted {
			return b.SetPreparedAccept(&c)
		}
	}

	return false
}

func (b *BallotProtocol) FederatedRatify(voted StatementPredicate) bool {
	return b.slot.FederatedRatify(voted, b.latestEnvelopes)
}

func (b *BallotProtocol) UpdateCurrentIfNeeded(h xdr.ScpBallot) bool {
	if b.currentBallot == nil || compareBallots(b.currentBallot, &h) < 0 {
		b.BumpToBallot(&h, true)
		return true
	}

	return false
}

func (b *BallotProtocol) SetPreparedConfirmed(newC, newH xdr.ScpBallot) bool {
	didWork := false

	// remember newH's value
	b.valueOverride = newH.Value

	// we don't set c/h if we're not on a compatible ballot
	if b.currentBallot == nil || areBallotsCompatible(b.currentBallot, &newH) {
		if b.highBallot == nil || compareBallots(&newH, b.highBallot) > 0 {
			didWork = true
			b.highBallot = &newH
		}

		if newC.Counter != 0 {
			b.commit = &newC
			didWork = true
		}

		if didWork {
			b.slot.SCPDriver().ConfirmedBallotPrepared(b.slot.Index(), &newH)
		}
	}

	// always perform step (8) with the computed value of h
	didWork = b.UpdateCurrentIfNeeded(newH) || didWork

	if didWork {
		b.EmitCurrentStateStatement()
	}

	return didWork
}

func (b *BallotProtocol) AttemptPreparedConfirmed(hint *xdr.ScpStatement) bool {
	if b.Phase != PhasePrepare {
		return false
	}

	// check if we could accept this ballot as prepared
	if b.prepared == nil {
		return false
	}

	candidates := b.GetPreparedCandidates(hint)
	newHFound := false

	// see if we can accept any of the candidates, starting with the highest
	var newH xdr.ScpBallot
	var cur int
	for i := len(candidates) - 1; i >= 0; i-- {
		// only consider it if we can potentially raise h
		if b.highBallot != nil && compareBallots(b.highBallot, &candidates[i]) >= 0 {
			cur = i
			break
		}

		ratified := b.FederatedRatify(
			func(st *xdr.ScpStatement) bool {
				return b.HasPreparedBallot(&candidates[i], st)
			},
		)
		if ratified {
			newH = candidates[i]
			newHFound = true
			cur = i
			break
		}
	}

	if !newHFound {
		return false
	}

	var newC xdr.ScpBallot
	// now, look for newC (left as 0 if no update)
	// step (3) from the paper
	ballot := b.currentBallot
	if ballot == nil {
		ballot = new(xdr.ScpBallot)
	}

	if b.commit == nil && (b.prepared == nil || !areBallotsLessAndIncompatible(&newH, b.prepared)) &&
		(b.preparedPrime == nil || !areBallotsLessAndIncompatible(&newH, b.preparedPrime)) {
		// continue where we left off (cur is at newH at this point)
		for i := cur; i >= 0; i-- {
			bal := candidates[i]
			if compareBallots(&bal, ballot) < 0 {
				break
			}

			// c and h must be compatible
			if !areBallotsLessAndCompatible(&candidates[i], &newH) {
				continue
			}

			ratified := b.FederatedRatify(
				func(st *xdr.ScpStatement) bool {
					return b.HasPreparedBallot(&bal, st)
				},
			)
			if ratified {
				newC = bal
			} else {
				break
			}
		}
	}

	return b.SetPreparedConfirmed(newC, newH)
}

func (b *BallotProtocol) CommitPredicate(ballot *xdr.ScpBallot, check Interval, st *xdr.ScpStatement) bool {
	res := false
	pl := st.Pledges
	switch pl.Type {
	case xdr.ScpStatementTypeScpStPrepare:
	case xdr.ScpStatementTypeScpStConfirm:
		c := pl.MustConfirm()
		if areBallotsCompatible(ballot, &c.Ballot) {
			res = c.NCommit <= xdr.Uint32(check.From) && xdr.Uint32(check.To) <= c.NH
		}
	case xdr.ScpStatementTypeScpStExternalize:
		e := pl.MustExternalize()
		if areBallotsCompatible(ballot, &e.Commit) {
			res = e.Commit.Counter <= xdr.Uint32(check.From)
		}
	default:
		panic("unexpected scp statement type")
	}
	return res
}

type boundariesSet []uint32

func (b boundariesSet) Less(i, j int) bool {
	return b[i] < b[j]
}

func (b boundariesSet) Len() int {
	return len(b)
}

func (b boundariesSet) Swap(i, j int) {
	tmp := b[i]
	b[i] = b[j]
	b[j] = tmp
}

func (b *boundariesSet) Put(u uint32) {
	for _, v := range *b {
		if v == u {
			return
		}
	}
	*b = append(*b, u)

	sort.Sort(b)
}

func (b *boundariesSet) Contains(u uint32) bool {
	for _, v := range *b {
		if v == u {
			return true
		}
	}

	return false
}

func (b *BallotProtocol) GetCommitBoundariesFromStatements(ballot *xdr.ScpBallot) boundariesSet {
	res := make(boundariesSet, 0)
	for _, env := range b.latestEnvelopes {
		pl := env.Statement.Pledges
		switch pl.Type {
		case xdr.ScpStatementTypeScpStPrepare:
			p := pl.MustPrepare()
			if areBallotsCompatible(ballot, &p.Ballot) {
				if p.NC != 0 {
					res.Put(uint32(p.NC))
					res.Put(uint32(p.NH))
				}
			}
		case xdr.ScpStatementTypeScpStConfirm:
			c := pl.MustConfirm()
			if areBallotsCompatible(ballot, &c.Ballot) {
				res.Put(uint32(c.NCommit))
				res.Put(uint32(c.NH))
			}
		case xdr.ScpStatementTypeScpStExternalize:
			e := pl.MustExternalize()
			if areBallotsCompatible(ballot, &e.Commit) {
				res.Put(uint32(e.Commit.Counter))
				res.Put(uint32(e.NH))
				res.Put(math.MaxUint32)
			}
		default:
			panic("unexpected scp statement type")
		}
	}
	return res
}

func (b *BallotProtocol) FindExtendedInterval(
	candidate *Interval,
	boundaries boundariesSet,
	pred func(Interval) bool,
) {
	// iterate through interesting boundaries, starting from the top
	sort.Sort(sort.Reverse(boundaries))
	for _, b := range boundaries {
		var cur Interval
		if candidate.From == 0 {
			// first, find the high bound
			cur = Interval{uint32(b), uint32(b)}
		} else if b > candidate.To { //invalid
			continue
		} else {
			cur.From = uint32(b)
			cur.To = candidate.To
		}

		if pred(cur) {
			*candidate = cur
		} else if candidate.From != 0 {
			// could not extend further
			break
		}
	}
}

func (b *BallotProtocol) SetAcceptCommit(c *xdr.ScpBallot, h *xdr.ScpBallot) bool {
	didWork := false

	// remember h's value
	b.valueOverride = h.Value

	if b.highBallot == nil || b.commit == nil || compareBallots(b.highBallot, h) != 0 ||
		compareBallots(b.commit, c) != 0 {
		b.commit = c
		b.highBallot = h
		didWork = true
	}

	if b.Phase == PhasePrepare {
		b.Phase = PhaseConfirm
		if b.currentBallot != nil && !areBallotsLessAndCompatible(h, b.currentBallot) {
			b.BumpToBallot(h, false)
		}
		b.preparedPrime = nil
		didWork = true
	}

	if didWork {
		b.UpdateCurrentIfNeeded(*b.highBallot)

		b.slot.SCPDriver().AcceptedCommit(b.slot.Index(), h)
		b.EmitCurrentStateStatement()
	}

	return didWork
}

func (b *BallotProtocol) AttemptAcceptCommit(hint *xdr.ScpStatement) bool {
	if b.Phase != PhasePrepare && b.Phase != PhaseConfirm {
		return false
	}

	// extracts value from hint
	// note: ballot.counter is only used for logging purpose as we're looking at
	// possible value to commit
	var ballot xdr.ScpBallot

	switch hint.Pledges.Type {
	case xdr.ScpStatementTypeScpStPrepare:
		prep := hint.Pledges.MustPrepare()
		if prep.NC != 0 {
			ballot = xdr.ScpBallot{
				Counter: prep.NH,
				Value:   prep.Ballot.Value,
			}
		} else {
			return false
		}
	case xdr.ScpStatementTypeScpStConfirm:
		con := hint.Pledges.MustConfirm()
		ballot = xdr.ScpBallot{
			Counter: con.NH,
			Value:   con.Ballot.Value,
		}

	case xdr.ScpStatementTypeScpStExternalize:
		ext := hint.Pledges.MustExternalize()
		ballot = xdr.ScpBallot{
			Counter: ext.NH,
			Value:   ext.Commit.Value,
		}
	default:
		panic("unexpected scp statement type")
	}

	if b.Phase == PhaseConfirm {
		if !areBallotsCompatible(&ballot, b.highBallot) {
			return false
		}
	}

	pred := func(cur Interval) bool {
		return b.FederatedAccept(
			func(st *xdr.ScpStatement) bool {
				res := false
				pl := st.Pledges
				switch pl.Type {
				case xdr.ScpStatementTypeScpStPrepare:
					p := pl.MustPrepare()
					if areBallotsCompatible(&ballot, &p.Ballot) {
						if p.NC != 0 {
							res = p.NC <= xdr.Uint32(cur.From) && xdr.Uint32(cur.To) <= p.NH
						}
					}
				case xdr.ScpStatementTypeScpStConfirm:
					c := pl.MustConfirm()
					if areBallotsCompatible(&ballot, &c.Ballot) {
						res = c.NCommit <= xdr.Uint32(cur.From)
					}
				case xdr.ScpStatementTypeScpStExternalize:
					e := pl.MustExternalize()
					if areBallotsCompatible(&ballot, &e.Commit) {
						res = e.Commit.Counter <= xdr.Uint32(cur.From)
					}
				default:
					panic("unexpected scp statement type")
				}
				return res
			},
			func(st *xdr.ScpStatement) bool {
				return b.CommitPredicate(&ballot, cur, st)
			},
		)
	}

	// build the boundaries to scan
	boundaries := b.GetCommitBoundariesFromStatements(&ballot)

	if len(boundaries) == 0 {
		return false
	}

	// now, look for the high interval
	var candidate Interval

	b.FindExtendedInterval(&candidate, boundaries, pred)

	res := false

	if candidate.From != 0 {
		if b.Phase != PhaseConfirm || candidate.To > uint32(b.highBallot.Counter) {
			c := xdr.ScpBallot{
				Counter: xdr.Uint32(candidate.From),
				Value:   ballot.Value,
			}
			h := xdr.ScpBallot{
				Counter: xdr.Uint32(candidate.To),
				Value:   ballot.Value,
			}
			res = b.SetAcceptCommit(&c, &h)
		}
	}

	return res
}

func (b *BallotProtocol) SetConfirmCommit(c *xdr.ScpBallot, h *xdr.ScpBallot) bool {
	b.commit = c
	b.highBallot = h
	b.UpdateCurrentIfNeeded(*b.highBallot)

	b.Phase = PhaseExternalize

	b.EmitCurrentStateStatement()
	b.slot.StopNomination()
	b.slot.SCPDriver().ValueExternalized(b.slot.Index(), b.commit.Value)
	return true
}

func (b *BallotProtocol) AttemptConfirmCommit(hint *xdr.ScpStatement) bool {
	if b.Phase != PhaseConfirm {
		return false
	}

	if b.highBallot == nil || b.commit == nil {
		return false
	}

	// extracts value from hint
	// note: ballot.counter is only used for logging purpose
	var ballot xdr.ScpBallot
	switch hint.Pledges.Type {
	case xdr.ScpStatementTypeScpStPrepare:
		return false
	case xdr.ScpStatementTypeScpStConfirm:
		con := hint.Pledges.MustConfirm()
		ballot = xdr.ScpBallot{
			Counter: con.NH,
			Value:   con.Ballot.Value,
		}
	case xdr.ScpStatementTypeScpStExternalize:
		ext := hint.Pledges.MustExternalize()
		ballot = xdr.ScpBallot{
			Counter: ext.NH,
			Value:   ext.Commit.Value,
		}
	default:
		panic("unexpected scp statement type")
	}

	if !areBallotsCompatible(&ballot, b.commit) {
		return false
	}

	boundaries := b.GetCommitBoundariesFromStatements(&ballot)
	var candidate Interval

	pred := func(cur Interval) bool {
		return b.FederatedRatify(
			func(st *xdr.ScpStatement) bool {
				return b.CommitPredicate(&ballot, cur, st)
			},
		)
	}

	b.FindExtendedInterval(&candidate, boundaries, pred)

	res := candidate.From != 0
	if res {
		c := xdr.ScpBallot{
			Counter: xdr.Uint32(candidate.From),
			Value:   ballot.Value,
		}
		h := xdr.ScpBallot{
			Counter: xdr.Uint32(candidate.To),
			Value:   ballot.Value,
		}
		res = b.SetConfirmCommit(&c, &h)
	}

	return res
}

func (b *BallotProtocol) AttemptBump() bool {
	if b.Phase == PhasePrepare || b.Phase == PhaseConfirm {
		// find all counters
		allCounters := make(map[uint32]struct{})
		for _, e := range b.latestEnvelopes {
			st := e.Statement
			switch st.Pledges.Type {
			case xdr.ScpStatementTypeScpStPrepare:
				p := st.Pledges.MustPrepare()
				allCounters[uint32(p.Ballot.Counter)] = struct{}{}
			case xdr.ScpStatementTypeScpStConfirm:
				c := st.Pledges.MustConfirm()
				allCounters[uint32(c.Ballot.Counter)] = struct{}{}
			case xdr.ScpStatementTypeScpStExternalize:
				allCounters[math.MaxUint32] = struct{}{}
			default:
				panic("unexpected scp statement type")
			}
		}

		targetCounter := uint32(0)
		if b.currentBallot != nil {
			targetCounter = uint32(b.currentBallot.Counter)
		}

		// uses 0 as a way to track if a v-blocking set is at a higher counter
		// if so, we move to that smallest counter
		allCounters[uint32(targetCounter)] = struct{}{}

		countersSlice := make([]int, 0, len(allCounters))
		for key := range allCounters {
			countersSlice = append(countersSlice, int(key))
		}
		sort.Ints(countersSlice)

		// go through the counters, find the smallest not v-blocking
		for _, n := range countersSlice {
			if n < int(targetCounter) {
				break
			}

			vBlocking := isVBlockingF(
				b.LocalNode().QuorumSet(), b.latestEnvelopes,
				func(st *xdr.ScpStatement) bool {
					res := false
					pl := st.Pledges
					if pl.Type == xdr.ScpStatementTypeScpStPrepare {
						p := pl.MustPrepare()
						res = n < int(p.Ballot.Counter)
					} else {
						if pl.Type == xdr.ScpStatementTypeScpStConfirm {
							res = n < int(pl.MustConfirm().Ballot.Counter)
						} else {
							res = n != math.MaxUint32
						}
					}
					return res
				},
			)

			if n == int(targetCounter) {
				// if current counter is not behind, don't do anything
				if !vBlocking {
					break
				}
			} else {
				if !vBlocking {
					// move to n
					return b.AbandonBallot(uint32(n))
				}
			}
		}
	}

	return false
}

func (b *BallotProtocol) AdvanceSlot(hint *xdr.ScpStatement) {
	b.currentMessageLevel++

	if b.currentMessageLevel >= MaxAdvanceSlotRecursion {
		panic("maximum number of transitions reached in advanceSlot")
	}

	// attempt* methods will queue up messages, causing advanceSlot to be
	// called recursively

	// done in order so that we follow the steps from the white paper in
	// order
	// allowing the state to be updated properly

	didWork := b.AttemptPreparedAccept(hint)
	didWork = b.AttemptPreparedConfirmed(hint) || didWork
	didWork = b.AttemptAcceptCommit(hint) || didWork
	didWork = b.AttemptConfirmCommit(hint) || didWork

	// only bump after we're done with everything else
	if b.currentMessageLevel == 1 {
		for {
			// attemptBump may invoke advanceSlot recursively
			didBump := b.AttemptBump()
			didWork = didWork || didBump
			if didBump == false {
				break
			}
		}

		b.CheckHeardFromQuorum()
	}

	b.currentMessageLevel--

	if didWork {
		b.SendLatestEnvelope()
	}
}

func (b *BallotProtocol) WorkingBallot(st *xdr.ScpStatement) xdr.ScpBallot {
	var res xdr.ScpBallot
	switch st.Pledges.Type {
	case xdr.ScpStatementTypeScpStPrepare:
		res = st.Pledges.MustPrepare().Ballot
	case xdr.ScpStatementTypeScpStConfirm:
		con := st.Pledges.MustConfirm()
		res = xdr.ScpBallot{
			Counter: con.NCommit,
			Value:   con.Ballot.Value,
		}
	case xdr.ScpStatementTypeScpStExternalize:
		res = st.Pledges.MustExternalize().Commit
	default:
		panic("unexpected scp statement type")
	}

	return res
}

func (b *BallotProtocol) ProcessEnvelope(env *xdr.ScpEnvelope, self bool) EnvelopeState {
	if !b.IsStatementSane(&env.Statement, self) {
		if self {
			log.Error("not sane statement from self, skipping")
		}

		return EnvelopeStateInvalid
	}

	if !b.IsNewerStatementN(xdr.PublicKey(env.Statement.NodeId), &env.Statement) {
		log.Debug("stale statement from self, skipping")

		return EnvelopeStateInvalid
	}

	validationRes := b.ValidateValues(&env.Statement)
	if validationRes == ValidationLevelInvalid {
		// If the value is not valid, we just ignore it.
		return EnvelopeStateInvalid
	}

	processed := false
	if b.Phase != PhaseExternalize {
		if validationRes == ValidationLevelMaybe {
			b.slot.SetFullyValidated(false)
		}

		b.RecordEnvelope(env)
		processed = true
		b.AdvanceSlot(&env.Statement)
	}

	if !processed {
		// note: this handles also our own messages
		// in particular our final EXTERNALIZE message

		if b.Phase == PhaseExternalize &&
			bytes.Compare(b.commit.Value, b.WorkingBallot(&env.Statement).Value) == 0 {
			b.RecordEnvelope(env)
			return EnvelopeStateValid
		}

		log.Error("externalize statement with invalid value from self, skipping")
		return EnvelopeStateInvalid
	}

	return EnvelopeStateValid
}

func (b *BallotProtocol) getCurrentState() (res []*xdr.ScpEnvelope) {
	for _, e := range b.latestEnvelopes {
		// only return messages for self if the slot is fully validated
		if !(*e.Statement.NodeId.Ed25519 == *b.slot.scp.LocalNodeID().Ed25519) ||
			b.slot.fullyValidated {
			res = append(res, e)
		}
	}
	return res
}

func (b *BallotProtocol) SetStatementFromEnvelope(e *xdr.ScpEnvelope) {
	if b.currentBallot != nil {
		panic("Cannot set state after starting ballot protocol")
	}

	b.RecordEnvelope(e)
	b.lastEnvelope = e
	b.lastEnvelopeEmit = e

	pl := e.Statement.Pledges

	switch pl.Type {
	case xdr.ScpStatementTypeScpStPrepare:
		prep := pl.MustPrepare()
		bal := prep.Ballot
		b.BumpToBallot(&bal, true)
		b.prepared = prep.Prepared
		b.preparedPrime = prep.PreparedPrime

		if prep.NH != 0 {
			b.highBallot = &xdr.ScpBallot{
				Counter: prep.NH,
				Value:   bal.Value,
			}
		}

		if prep.NC != 0 {
			b.commit = &xdr.ScpBallot{
				Counter: prep.NC,
				Value:   bal.Value,
			}
		}

		b.Phase = PhasePrepare
	case xdr.ScpStatementTypeScpStConfirm:
		c := pl.MustConfirm()
		v := c.Ballot.Value
		b.BumpToBallot(&c.Ballot, true)
		b.prepared = &xdr.ScpBallot{
			Counter: c.NPrepared,
			Value:   v,
		}
		b.highBallot = &xdr.ScpBallot{
			Counter: c.NH,
			Value:   v,
		}
		b.Phase = PhaseConfirm
	case xdr.ScpStatementTypeScpStExternalize:
		ext := pl.MustExternalize()
		v := ext.Commit.Value
		b.BumpToBallot(&xdr.ScpBallot{
			Counter: math.MaxUint32,
			Value:   v,
		}, true)
		b.prepared = &xdr.ScpBallot{
			Counter: math.MaxUint32,
			Value:   v,
		}
		b.highBallot = &xdr.ScpBallot{
			Counter: ext.NH,
			Value:   v,
		}
		b.commit = &ext.Commit
		b.Phase = PhaseExternalize

	default:
		panic("unexpected scp statement type")
	}
}
